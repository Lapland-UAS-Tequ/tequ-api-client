[{"id":"a8f9c56ab53d5597","type":"subflow","name":"[AI] Predict","info":"Run prediction on input image using Tensorflow model in saved model format. \n\nInput image must be image buffer in 'msg.payload'.\n\nimage_width_cm is set in 'settings.js'-file. \n\nprocess.env.image_width_cm = JSON.stringify({\"10\":130,\"11\":130,\"20\":130,\"21\":130});","category":"Tequ-API","in":[{"x":100,"y":100,"wires":[{"id":"c5a286fefafc2afa"}]}],"out":[{"x":1020,"y":180,"wires":[{"id":"f7dcae4151ae5e03","port":0}]}],"env":[{"name":"model_folder","type":"str","value":"savedmodel","ui":{"type":"input","opts":{"types":["str","env"]}}},{"name":"threshold","type":"num","value":"0.75","ui":{"type":"spinner","opts":{"min":0,"max":1}}},{"name":"image_width_cm","type":"env","value":"image_width_cm","ui":{"type":"input","opts":{"types":["env"]}}}],"meta":{"version":"0.0.1","author":"juha.autioniemi@lapinamk.fi","desc":"Run prediction on input image using TF2 Savedmodel.","license":"MIT"},"color":"#FFCC66","inputLabels":["msg.payload (image buffer)"],"outputLabels":["result"],"icon":"node-red/status.svg","status":{"x":1020,"y":240,"wires":[{"id":"7b9b955ca863c7e6","port":0}]}},{"id":"f7dcae4151ae5e03","type":"function","z":"a8f9c56ab53d5597","name":"Predict saved model","func":"model = context.get(\"model\")\nvar imageBuffer = msg.payload;\nvar results = [];\nvar labels = context.get(\"labels\");\nvar threshold = msg.threshold;\nvar image_width = msg.width;\nvar image_height = msg.height;\n\nasync function processModel(input){\n    //const model = await tf.node.loadSavedModel(\"C:\\\\Users\\\\juha.autioniemi\\\\Downloads\\\\centernet_hg104_1024x1024_coco17_tpu-32.tar\\\\saved_model\", ['serve'], 'serving_default');\n    \n    outputTensor = model.predict(input);\n    const scores = outputTensor['detection_scores'].arraySync();\n    const boxes = outputTensor['detection_boxes'].arraySync();\n    const names = outputTensor['detection_classes'].arraySync();\n    outputTensor['detection_scores'].dispose();\n    outputTensor['detection_boxes'].dispose();\n    outputTensor['detection_classes'].dispose();\n    outputTensor['num_detections'].dispose();\n\n    //node.send({payload:{\n    //    \"scores\":scores,\n    //    \"boxes\":boxes,\n    //    \"names\":names\n    //}})\n\n    var results = []\n\n    for (let i = 0; i < scores[0].length; i++) {\n        if (scores[0][i] > threshold) {\n            newObject = {\n                \"bbox\":[\n                    boxes[0][i][1] * image_width,\n                    boxes[0][i][0] * image_height,\n                    (boxes[0][i][3] - boxes[0][i][1]) * image_width,\n                    (boxes[0][i][2] - boxes[0][i][0]) * image_height\n                    ],\n                \"class\":labels[names[0][i]-1],\n                \"label\":labels[names[0][i]-1],\n                \"score\":scores[0][i],\n                \"length_cm\":NaN\n            }\n            results.push(newObject)\n        }\n    }\n    return results;\n}\n    \nconst image = tf.tidy(() => {\n  return tf.node.decodeImage(msg.payload, 3).expandDims(0);\n});\n\n\nresults = await processModel({input_tensor: image});\n\n//Calculate object width if image_width_cm is given input message\nif(\"image_width_cm\" in msg){\n    var image_width_cm = msg.image_width_cm;\n\n    for(var j=0;j<results.length;j++){\n        px_in_cm = image_width_cm / msg.width\n        object_size_cm = px_in_cm * results[j].bbox[2]\n        results[j].length_cm = Math.round(object_size_cm)\n    }\n}\n\n// Create output message\nresult_message = {\n    \"labels\":context.get(\"labels\"),\n    \"thresholdType\":msg.thresholdType,\n    \"threshold\": msg.threshold,\n    \"image_width_cm\":msg.image_width_cm,\n    \"image_width_cm_type\":msg.image_width_cm_type,\n    \"topic\":msg.topic,\n    \"payload\":{\n        \"inference\":{\n            \"metadata\":context.get(\"metadata\"),\n            \"time_ms\": new Date().getTime() - msg.start,\n            \"result\":results,\n            \"type\":\"object detection\"\n        },\n        \"image\":{\n            \"buffer\":imageBuffer,\n            \"width\": msg.width,\n            \"height\": msg.height,\n            \"type\": msg.type,\n            \"size\": (imageBuffer).length,\n            \"exif\":{}\n        }\n    }\n}\n\n// Add exif information\nif(msg.exif){\n     result_message.payload.image.exif = msg.exif\n}\nnode.status({fill:\"blue\",shape:\"dot\",text:(result_message.payload.inference.result).length+\" object(s) found in \"+ result_message.payload.inference.time_ms+\" ms\"});  \nreturn result_message;","outputs":1,"noerr":0,"initialize":"// Code added here will be run once\n// whenever the node is started.\n// Code added here will be run once\n// whenever the node is started.\nmodel_folder = env.get(\"model_folder\")\nmodel_file = model_folder+\"\\\\saved_model.pb\"\nlabels_file = model_folder+\"\\\\labels.json\"\nmetadata_file = model_folder+\"\\\\metadata.json\"\nnode.status({fill:\"yellow\",shape:\"dot\",text:\"Loading...\"+model_folder})    \n\nif (context.get(\"labels\") === undefined) {\n    try {\n        context.set(\"labels\",JSON.parse(fs.readFileSync(labels_file, 'utf8')))\n    } catch (err) {\n        node.error(\"Error reading labels\",err)\n    }\n}\n\nif (context.get(\"metadata\") === undefined) {\n    try {\n        context.set(\"metadata\",JSON.parse(fs.readFileSync(metadata_file, 'utf8')))\n    } catch (err) {\n        node.error(\"Error reading metadata\",err)\n    }\n}\n\ntry {\n        if(fs.existsSync(model_folder)){\n            if(fs.existsSync(model_file)){\n                    const model = await tf.node.loadSavedModel(model_folder)\n                    const modelInfo = await tf.node.getMetaGraphsFromSavedModel(model_folder);\n                    context.set(\"model\",model)\n                    context.set(\"modelInfo\",modelInfo)\n                    node.status({fill:\"green\",shape:\"dot\",text:\"Model ready.\"})    \n            }\n            else{\n                node.status({fill:\"red\",shape:\"dot\",text:\"saved_model.pb not found\"})    \n            }\n        }\n        else{\n            node.status({fill:\"red\",shape:\"dot\",text:\"Model folder \"+model_folder+\" not found\"})\n        }\n}\ncatch (err) {\n        node.status({fill:\"red\",shape:\"dot\",text:\"Error loading model\"})\n        node.error(err,err)\n}","finalize":"","libs":[{"var":"fs","module":"fs"},{"var":"tf","module":"@tensorflow/tfjs-node-gpu"}],"x":820,"y":180,"wires":[[]]},{"id":"9bfed88bd17feb87","type":"image-info","z":"a8f9c56ab53d5597","name":"","x":390,"y":100,"wires":[["bc1a5d07373f3350"]]},{"id":"bc1a5d07373f3350","type":"exif","z":"a8f9c56ab53d5597","name":"","mode":"normal","property":"payload","x":550,"y":100,"wires":[["a9d1887a1a850822"]]},{"id":"a9d1887a1a850822","type":"function","z":"a8f9c56ab53d5597","name":"Set threshold & image_width_cm","func":"//Define threshold\nvar threshold = 0;\n\nglobal_settings = global.get(\"settings\") || undefined\nvar thresholdType = \"\"\n\nif(global_settings !== undefined){\n    if(\"threshold\" in global_settings){\n        threshold = global_settings[\"threshold\"]\n        thresholdType = \"global\";\n    }\n}\n\nelse if(\"threshold\" in msg){\n    threshold = msg.threshold;\n    thresholdType = \"msg\";\n    if(threshold < 0){\n        threshold = 0\n    }\n    else if(threshold > 1){\n        threshold = 1\n    }\n}\n\nelse{\n    try{\n        threshold = env.get(\"threshold\");\n        thresholdType = \"env\";\n    }\n    catch(err){\n        threshold = 0.5\n        thresholdType = \"default\";\n    }\n    \n    \n   \n}\n\n\ntry{\n    image_width_cm_type = \"env\";\n    image_width_cm = JSON.parse(env.get(\"image_width_cm\"))[msg.topic];\n        \n}\ncatch(err){\n    image_width_cm = 130\n    image_width_cm_type = \"default\";\n}\n\n\nif(threshold == undefined){\n    threshold = 0\n}\n\nmsg.thresholdType = thresholdType;\nmsg.threshold = threshold;\nmsg.image_width_cm = image_width_cm;\nmsg.image_width_cm_type = image_width_cm_type;\n//node.status({fill:\"green\",shape:\"dot\",text:\"threshold: \"+threshold+\" | Image width: \"+image_width_cm});\nreturn msg;","outputs":1,"noerr":0,"initialize":"","finalize":"","libs":[],"x":780,"y":100,"wires":[["f7dcae4151ae5e03"]]},{"id":"c5a286fefafc2afa","type":"function","z":"a8f9c56ab53d5597","name":"isBuffer?","func":"timestamp = new Date().toISOString();\nmsg.start = new Date().getTime()\n\nif(Buffer.isBuffer(msg.payload)){\n    //node.status({fill:\"green\",shape:\"dot\",text:timestamp + \" OK\"});  \n    return msg;\n}\nelse{\n    node.error(\"msg.payload is not an image buffer\",msg)\n    node.status({fill:\"red\",shape:\"dot\",text:timestamp + \" msg.payload is not an image buffer\"});  \n    return null;\n}","outputs":1,"noerr":0,"initialize":"","finalize":"","libs":[],"x":220,"y":100,"wires":[["9bfed88bd17feb87"]]},{"id":"7b9b955ca863c7e6","type":"status","z":"a8f9c56ab53d5597","name":"","scope":["f7dcae4151ae5e03","c5a286fefafc2afa"],"x":860,"y":240,"wires":[[]]},{"id":"630e1406131fb14b","type":"subflow:a8f9c56ab53d5597","z":"052609f64ccd60c1","name":"","env":[],"x":270,"y":720,"wires":[[]]}]